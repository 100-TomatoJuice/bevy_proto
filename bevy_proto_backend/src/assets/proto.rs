use crate::assets::{AssetSchematic, PreloadAssetSchematic};
use crate::deps::DependenciesBuilder;
use crate::schematics::{
    FromSchematicInput, FromSchematicPreloadInput, SchematicContext, SchematicId,
};
use bevy::asset::{Asset, AssetServer, Assets, Handle, HandleId};
use bevy::prelude::Reflect;
use bevy::reflect::TypeUuid;
use std::fmt::{Debug, Formatter};
use std::hash::{Hash, Hasher};

/// Replacement type for asset handles in a [`Schematic::Input`] generated by the
/// [derive macro].
///
/// This allows assets to be referenced by path from within a schematic.
/// To inline an asset, use [`InlinableProtoAsset`].
///
/// [`Schematic::Input`]: crate::schematics::Schematic::Input
/// [derive macro]: bevy_proto_derive::Schematic
#[derive(Reflect)]
pub enum ProtoAsset<T: Asset> {
    /// The path to an asset relative to the `assets` directory.
    AssetPath(String),
    /// An existing [`Handle`].
    ///
    /// Note: This handle should always be _weak_.
    Handle(Handle<T>),
}

impl<T: Asset> Default for ProtoAsset<T> {
    fn default() -> Self {
        Self::Handle(Handle::default())
    }
}

impl<T: Asset> Clone for ProtoAsset<T> {
    fn clone(&self) -> Self {
        match self {
            Self::AssetPath(path) => Self::AssetPath(path.clone()),
            Self::Handle(handle) => Self::Handle(handle.clone()),
        }
    }
}

impl<T: Asset> Debug for ProtoAsset<T> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AssetPath(path) => f.debug_tuple("AssetPath").field(path).finish(),
            Self::Handle(handle) => f.debug_tuple("Handle").field(handle).finish(),
        }
    }
}

impl<T: Asset> Eq for ProtoAsset<T> {}

impl<T: Asset> PartialEq for ProtoAsset<T> {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::AssetPath(a), Self::AssetPath(b)) => a == b,
            (Self::Handle(a), Self::Handle(b)) => a == b,
            _ => false,
        }
    }
}

impl<T: Asset> Hash for ProtoAsset<T> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        match self {
            ProtoAsset::AssetPath(path) => path.hash(state),
            ProtoAsset::Handle(handle) => handle.hash(state),
        }
    }
}

impl<T: Asset> From<Handle<T>> for ProtoAsset<T> {
    fn from(value: Handle<T>) -> Self {
        Self::Handle(value.clone_weak())
    }
}

impl<T: Asset> FromSchematicInput<ProtoAsset<T>> for Handle<T> {
    fn from_input(input: ProtoAsset<T>, _id: SchematicId, context: &mut SchematicContext) -> Self {
        match input {
            ProtoAsset::AssetPath(path) => context.world().resource::<AssetServer>().load(path),
            ProtoAsset::Handle(handle) => {
                context.world().resource::<AssetServer>().get_handle(handle)
            }
        }
    }
}

impl<T: Asset> FromSchematicPreloadInput<ProtoAsset<T>> for Handle<T> {
    /// # Panics
    ///
    /// This will panic if the input is a [`ProtoAsset::Handle`].
    fn from_preload_input(
        input: ProtoAsset<T>,
        _id: SchematicId,
        dependencies: &mut DependenciesBuilder,
    ) -> Self {
        match input {
            ProtoAsset::AssetPath(path) => dependencies.add_dependency(path),
            ProtoAsset::Handle(_) => unimplemented!("cannot preload a handle"),
        }
    }
}

/// Replacement type for asset handles in a [`Schematic::Input`] generated by the
/// [derive macro].
///
/// Unlike the base [`ProtoAsset`], this type allows for assets to be inlined
/// using the [`AssetSchematic`] trait.
///
/// [`Schematic::Input`]: crate::schematics::Schematic::Input
/// [derive macro]: bevy_proto_derive::Schematic
#[derive(Reflect)]
pub enum InlinableProtoAsset<T: AssetSchematic> {
    /// The input to an [`AssetSchematic`] of type `T`.
    ///
    /// This is used to generate the actual asset at runtime.
    Asset(T::Input),
    /// The path to an asset relative to the `assets` directory.
    AssetPath(String),
    /// An existing [`Handle`].
    Handle(Handle<T::Output>),
}

impl<T: AssetSchematic> Default for InlinableProtoAsset<T> {
    fn default() -> Self {
        Self::Handle(Handle::default())
    }
}

impl<T: AssetSchematic> FromSchematicInput<InlinableProtoAsset<T>> for Handle<T::Output> {
    fn from_input(
        input: InlinableProtoAsset<T>,
        id: SchematicId,
        context: &mut SchematicContext,
    ) -> Self {
        match input {
            InlinableProtoAsset::Asset(input) => {
                let asset = T::load(
                    &input,
                    id.next(bevy::utils::Uuid::from_u128(
                        0x54e193c39c62443da0884276371f0a27,
                    )),
                    context,
                );
                context.world_mut().resource_mut::<Assets<T::Output>>().set(
                    HandleId::new(
                        T::Output::TYPE_UUID,
                        id.next(bevy::utils::Uuid::from_u128(
                            0xf9dd72f06c22482fa0bdd45b417cb946,
                        ))
                        .value(),
                    ),
                    asset,
                )
            }
            InlinableProtoAsset::AssetPath(path) => {
                context.world().resource::<AssetServer>().load(path)
            }
            InlinableProtoAsset::Handle(handle) => {
                context.world().resource::<AssetServer>().get_handle(handle)
            }
        }
    }
}

impl<T: PreloadAssetSchematic> FromSchematicPreloadInput<InlinableProtoAsset<T>>
    for Handle<T::Output>
{
    /// # Panics
    ///
    /// This will panic if the input is a [`InlinableProtoAsset::Handle`].
    fn from_preload_input(
        input: InlinableProtoAsset<T>,
        id: SchematicId,
        dependencies: &mut DependenciesBuilder,
    ) -> Self {
        match input {
            InlinableProtoAsset::Asset(input) => {
                let asset = T::preload(
                    input,
                    id.next(bevy::utils::Uuid::from_u128(
                        0x54e193c39c62443da0884276371f0a27,
                    )),
                    dependencies,
                );
                dependencies.add_asset(
                    asset,
                    format!(
                        "{}",
                        id.next(bevy::utils::Uuid::from_u128(
                            0x5760fb8ae11d4936986f5f19226c3e58
                        ))
                        .value()
                    ),
                )
            }
            InlinableProtoAsset::AssetPath(path) => dependencies.add_dependency(path),
            InlinableProtoAsset::Handle(_) => unimplemented!("cannot preload a handle"),
        }
    }
}
